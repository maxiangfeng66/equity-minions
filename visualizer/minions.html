<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equity Research - Multi-AI Workflow</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a1a;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            height: 100vh;
        }

        /* Main Stage */
        .stage {
            position: relative;
            background: linear-gradient(180deg, #1e1e3f 0%, #0d0d1a 100%);
            overflow: hidden;
        }

        /* Pixel grid background */
        .pixel-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                linear-gradient(rgba(0,212,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,212,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Header */
        .header {
            position: absolute;
            top: 0; left: 0; right: 0;
            padding: 12px 20px;
            background: rgba(0,0,0,0.8);
            border-bottom: 3px solid #7c3aed;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: #00d4ff;
            text-shadow: 2px 2px #7c3aed;
        }

        .ticker-display {
            font-family: 'Press Start 2P', cursive;
            background: #7c3aed;
            padding: 8px 16px;
            font-size: 0.7rem;
            color: #fff;
            border: 3px solid #fff;
            box-shadow: 4px 4px 0 #000;
        }

        .status-bar {
            display: flex;
            gap: 15px;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        .status-dot {
            width: 12px; height: 12px;
            background: #444;
            border: 2px solid #fff;
        }
        .status-dot.connecting { background: #ffaa00; animation: blink 0.5s infinite; }
        .status-dot.connected { background: #00ff88; }
        .status-dot.running { background: #00d4ff; animation: blink 0.3s infinite; }
        .status-dot.complete { background: #00ff88; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Flowchart container */
        .flowchart {
            position: absolute;
            top: 60px; left: 0; right: 0; bottom: 70px;
            padding: 10px 20px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .flowchart::-webkit-scrollbar {
            width: 10px;
        }

        .flowchart::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 5px;
        }

        .flowchart::-webkit-scrollbar-thumb {
            background: #7c3aed;
            border-radius: 5px;
        }

        .flowchart::-webkit-scrollbar-thumb:hover {
            background: #9d5cff;
        }

        .flowchart-inner {
            position: relative;
            width: 100%;
            min-height: 900px;
            height: 900px;
        }

        /* SVG for connections */
        .connections-svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        .connection {
            stroke: #333;
            stroke-width: 3;
            fill: none;
            stroke-dasharray: 8, 4;
        }

        .connection.active {
            stroke: #00d4ff;
            stroke-width: 4;
            filter: drop-shadow(0 0 6px #00d4ff);
            animation: flowDash 0.5s linear infinite;
        }

        @keyframes flowDash {
            to { stroke-dashoffset: -12; }
        }

        .connection.complete {
            stroke: #00ff88;
            stroke-dasharray: none;
        }

        /* Agent nodes */
        .agent-node {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s;
            cursor: pointer;
        }

        .agent-node:hover { transform: scale(1.1); }

        .minion-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
        }

        .minion-avatar svg {
            width: 100%;
            height: 100%;
        }

        .agent-node.idle .minion-avatar {
            opacity: 0.4;
            filter: grayscale(0.5) drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        .agent-node.active .minion-avatar {
            filter: drop-shadow(0 0 15px #ffaa00);
            animation: minionBounce 0.5s ease-in-out infinite;
        }
        .agent-node.thinking .minion-avatar {
            filter: drop-shadow(0 0 20px #00d4ff);
            animation: minionBounce 0.3s ease-in-out infinite, minionShake 0.1s ease-in-out infinite;
        }
        .agent-node.complete .minion-avatar {
            filter: drop-shadow(0 0 15px #00ff88);
            animation: minionCelebrate 0.5s ease-in-out;
        }
        .agent-node.error .minion-avatar {
            filter: drop-shadow(0 0 15px #ff4444) grayscale(0.3);
            animation: minionSad 0.5s ease-in-out;
        }

        /* OFFICE MINION ANIMATIONS */

        /* Idle breathing animation - all minions "breathe" */
        @keyframes minionIdle {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-2px) scale(1.02); }
        }

        /* Idle looking around - eyes move */
        @keyframes minionLookAround {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-1px); }
            75% { transform: translateX(1px); }
        }

        /* Active working bounce */
        @keyframes minionBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-12px) scale(1.05); }
        }

        /* Thinking shake */
        @keyframes minionShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Complete celebration */
        @keyframes minionCelebrate {
            0% { transform: scale(1); }
            25% { transform: scale(1.15) rotate(-5deg); }
            50% { transform: scale(1.2) rotate(10deg); }
            75% { transform: scale(1.15) rotate(-3deg); }
            100% { transform: scale(1) rotate(0); }
        }

        /* Error sad */
        @keyframes minionSad {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(5px) scale(0.95); }
        }

        /* Typing animation for working minions */
        @keyframes minionTyping {
            0%, 100% { transform: translateY(0) rotate(0); }
            10% { transform: translateY(-1px) rotate(-2deg); }
            20% { transform: translateY(0) rotate(2deg); }
            30% { transform: translateY(-1px) rotate(-1deg); }
            40% { transform: translateY(0) rotate(1deg); }
            50% { transform: translateY(-1px) rotate(-2deg); }
        }

        /* Coffee sip animation */
        @keyframes minionCoffee {
            0%, 90%, 100% { transform: translateY(0); }
            95% { transform: translateY(-3px); }
        }

        /* Wave animation for greeting */
        @keyframes minionWave {
            0%, 100% { transform: rotate(0); }
            25% { transform: rotate(-15deg); }
            75% { transform: rotate(15deg); }
        }

        /* Glow effect for active nodes */
        @keyframes glowPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 218, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 218, 0, 0.7), 0 0 50px rgba(255, 218, 0, 0.3); }
        }

        /* Floating particles around thinking minions */
        @keyframes floatParticle {
            0% { transform: translateY(0) translateX(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) translateX(10px) scale(0); opacity: 0; }
        }

        /* Office desk bounce in */
        @keyframes deskAppear {
            0% { transform: scale(0) translateY(20px); opacity: 0; }
            70% { transform: scale(1.1) translateY(-5px); }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        /* Apply idle animation to all minions */
        .agent-node .minion-avatar {
            animation: minionIdle 3s ease-in-out infinite;
        }

        /* Each minion has slightly different timing */
        .agent-node:nth-child(odd) .minion-avatar {
            animation-delay: 0.5s;
        }
        .agent-node:nth-child(3n) .minion-avatar {
            animation-duration: 3.5s;
        }
        .agent-node:nth-child(5n) .minion-avatar {
            animation-duration: 2.8s;
        }

        /* Override for active states */
        .agent-node.idle .minion-avatar {
            animation: minionIdle 3s ease-in-out infinite, minionCoffee 15s ease-in-out infinite;
        }

        .agent-node.active .minion-avatar {
            animation: minionTyping 0.3s ease-in-out infinite, glowPulse 1s ease-in-out infinite !important;
        }

        .agent-node.thinking .minion-avatar {
            animation: minionBounce 0.5s ease-in-out infinite, minionShake 0.1s ease-in-out infinite, glowPulse 0.5s ease-in-out infinite !important;
        }

        .agent-node.complete .minion-avatar {
            animation: minionCelebrate 0.6s ease-in-out !important;
        }

        /* Desk/workspace under each minion */
        .agent-node::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 42px;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(100, 100, 150, 0.3), transparent);
            border-radius: 2px;
        }

        /* Thought bubbles for thinking minions */
        .thought-bubble {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 100;
        }

        .thought-bubble::before,
        .thought-bubble::after,
        .thought-bubble span {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: floatParticle 1s ease-out infinite;
        }

        .thought-bubble::before {
            width: 8px;
            height: 8px;
            bottom: 0;
            left: 0;
        }

        .thought-bubble::after {
            width: 5px;
            height: 5px;
            bottom: 8px;
            left: 10px;
            animation-delay: 0.3s;
        }

        .thought-bubble span {
            width: 4px;
            height: 4px;
            bottom: 14px;
            left: 18px;
            animation-delay: 0.6s;
        }

        .agent-node.thinking .thought-bubble {
            display: block;
        }

        .agent-name {
            margin-top: 3px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.35rem;
            color: #888;
            text-align: center;
            max-width: 60px;
            line-height: 1.2;
        }

        .agent-node.active .agent-name,
        .agent-node.thinking .agent-name { color: #fff; }

        /* Speech bubble */
        .speech-bubble {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            color: #000;
            padding: 6px 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.4rem;
            border: 3px solid #000;
            max-width: 120px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #000;
        }

        .agent-node.thinking .speech-bubble,
        .agent-node.speaking .speech-bubble { opacity: 1; }

        /* Agent Chatbox - shows current task */
        .agent-chatbox {
            position: absolute;
            left: calc(100% + 12px);
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #1a1a3a 0%, #0d0d2a 100%);
            border: 2px solid #7c3aed;
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 180px;
            max-width: 250px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(124, 58, 237, 0.3);
            cursor: pointer;
        }

        .agent-chatbox:hover {
            transform: translateY(-50%) scale(1.02);
            box-shadow: 0 6px 30px rgba(124, 58, 237, 0.6);
            border-width: 3px;
        }

        .agent-chatbox .expand-hint {
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 0.6rem;
            color: #888;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .agent-chatbox:hover .expand-hint {
            opacity: 1;
            color: #fff;
        }

        /* Arrow pointing to agent */
        .agent-chatbox::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: #7c3aed;
        }

        .agent-chatbox::after {
            content: '';
            position: absolute;
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
            border: 5px solid transparent;
            border-right-color: #1a1a3a;
        }

        /* Show chatbox when agent is active or thinking */
        .agent-node.active .agent-chatbox,
        .agent-node.thinking .agent-chatbox {
            opacity: 1;
            pointer-events: auto;
            animation: chatboxAppear 0.3s ease-out;
        }

        @keyframes chatboxAppear {
            from { opacity: 0; transform: translateY(-50%) translateX(-10px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .chatbox-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(124, 58, 237, 0.3);
        }

        .chatbox-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00d4ff;
            animation: pulse 1s ease-in-out infinite;
        }

        .agent-node.thinking .chatbox-status {
            background: #ffaa00;
            animation: pulse 0.5s ease-in-out infinite;
        }

        .agent-node.complete .chatbox-status {
            background: #00ff88;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .chatbox-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.35rem;
            color: #00d4ff;
            text-transform: uppercase;
            flex: 1;
        }

        .chatbox-ticker {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.3rem;
            color: #7c3aed;
            background: rgba(124, 58, 237, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .chatbox-agent-name {
            font-size: 0.65rem;
            color: #fff;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .chatbox-task {
            font-size: 0.65rem;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
            min-height: 2.5em;
        }

        .chatbox-detail {
            font-size: 0.6rem;
            color: #666;
            font-style: italic;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px dashed rgba(255,255,255,0.1);
        }

        /* Live output preview - scrolling text effect */
        .chatbox-output {
            font-size: 0.6rem;
            color: #0f0;
            font-family: 'Consolas', monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 8px;
            border-radius: 4px;
            margin-top: 6px;
            max-height: 60px;
            overflow: hidden;
            position: relative;
            line-height: 1.4;
        }

        .chatbox-output::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
        }

        .chatbox-output.typing::before {
            content: '▌';
            animation: blink 0.5s infinite;
            color: #0f0;
        }

        /* Debate-specific styling */
        .agent-node .agent-chatbox.debate-bull {
            border-color: #22c55e !important;
            box-shadow: 0 4px 20px rgba(34, 197, 94, 0.3);
        }
        .agent-node .agent-chatbox.debate-bull::before { border-right-color: #22c55e !important; }
        .agent-node[data-side="left"] .agent-chatbox.debate-bull::before { border-left-color: #22c55e !important; border-right-color: transparent !important; }
        .agent-node .agent-chatbox.debate-bull .chatbox-title { color: #22c55e; }
        .agent-node .agent-chatbox.debate-bull .chatbox-output { color: #4ade80; }

        .agent-node .agent-chatbox.debate-bear {
            border-color: #ef4444 !important;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
        }
        .agent-node .agent-chatbox.debate-bear::before { border-right-color: #ef4444 !important; }
        .agent-node[data-side="left"] .agent-chatbox.debate-bear::before { border-left-color: #ef4444 !important; border-right-color: transparent !important; }
        .agent-node .agent-chatbox.debate-bear .chatbox-title { color: #ef4444; }
        .agent-node .agent-chatbox.debate-bear .chatbox-output { color: #f87171; }

        .agent-node .agent-chatbox.debate-devil {
            border-color: #a855f7 !important;
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.3);
        }
        .agent-node .agent-chatbox.debate-devil::before { border-right-color: #a855f7 !important; }
        .agent-node[data-side="left"] .agent-chatbox.debate-devil::before { border-left-color: #a855f7 !important; border-right-color: transparent !important; }
        .agent-node .agent-chatbox.debate-devil .chatbox-title { color: #a855f7; }
        .agent-node .agent-chatbox.debate-devil .chatbox-output { color: #c084fc; }

        /* Wider chatbox for debate agents */
        .agent-node .agent-chatbox.debate-bull,
        .agent-node .agent-chatbox.debate-bear,
        .agent-node .agent-chatbox.debate-devil {
            min-width: 280px;
            max-width: 350px;
        }

        /* Taller output area for debate agents */
        .agent-node .agent-chatbox.debate-bull .chatbox-output,
        .agent-node .agent-chatbox.debate-bear .chatbox-output,
        .agent-node .agent-chatbox.debate-devil .chatbox-output {
            max-height: 80px;
            min-height: 50px;
        }

        /* Provider badge in chatbox */
        .chatbox-provider {
            font-size: 0.4rem;
            color: #666;
            margin-top: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chatbox-provider-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #666;
        }

        .chatbox-provider-dot.openai { background: #10a37f; }
        .chatbox-provider-dot.google { background: #4285f4; }
        .chatbox-provider-dot.xai { background: #e44d26; }
        .chatbox-provider-dot.dashscope { background: #ff6a00; }

        .chatbox-progress {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chatbox-progress-bar {
            flex: 1;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .chatbox-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7c3aed);
            width: 0%;
            animation: progressPulse 2s ease-in-out infinite;
        }

        @keyframes progressPulse {
            0% { width: 20%; }
            50% { width: 80%; }
            100% { width: 20%; }
        }

        .agent-node.complete .chatbox-progress-fill {
            width: 100%;
            animation: none;
        }

        .chatbox-time {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.3rem;
            color: #666;
        }

        /* Position adjustments for nodes on the right side */
        .agent-node[data-side="left"] .agent-chatbox {
            left: auto;
            right: calc(100% + 12px);
        }

        .agent-node[data-side="left"] .agent-chatbox::before {
            left: auto;
            right: -8px;
            border-right-color: transparent;
            border-left-color: #7c3aed;
        }

        .agent-node[data-side="left"] .agent-chatbox::after {
            left: auto;
            right: -5px;
            border-right-color: transparent;
            border-left-color: #1a1a3a;
        }

        /* Different border colors by provider */
        .agent-node .agent-chatbox.provider-openai { border-color: #10a37f; }
        .agent-node .agent-chatbox.provider-openai::before { border-right-color: #10a37f; }
        .agent-node[data-side="left"] .agent-chatbox.provider-openai::before { border-left-color: #10a37f; border-right-color: transparent; }
        .agent-node .agent-chatbox.provider-openai .chatbox-title { color: #10a37f; }

        .agent-node .agent-chatbox.provider-google { border-color: #4285f4; }
        .agent-node .agent-chatbox.provider-google::before { border-right-color: #4285f4; }
        .agent-node[data-side="left"] .agent-chatbox.provider-google::before { border-left-color: #4285f4; border-right-color: transparent; }
        .agent-node .agent-chatbox.provider-google .chatbox-title { color: #4285f4; }

        .agent-node .agent-chatbox.provider-xai { border-color: #e44d26; }
        .agent-node .agent-chatbox.provider-xai::before { border-right-color: #e44d26; }
        .agent-node[data-side="left"] .agent-chatbox.provider-xai::before { border-left-color: #e44d26; border-right-color: transparent; }
        .agent-node .agent-chatbox.provider-xai .chatbox-title { color: #e44d26; }

        .agent-node .agent-chatbox.provider-dashscope { border-color: #ff6a00; }
        .agent-node .agent-chatbox.provider-dashscope::before { border-right-color: #ff6a00; }
        .agent-node[data-side="left"] .agent-chatbox.provider-dashscope::before { border-left-color: #ff6a00; border-right-color: transparent; }
        .agent-node .agent-chatbox.provider-dashscope .chatbox-title { color: #ff6a00; }

        /* Bottom stats */
        .stats-bar {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            padding: 15px 20px;
            background: rgba(0,0,0,0.9);
            border-top: 3px solid #7c3aed;
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        .stat {
            text-align: center;
            font-family: 'Press Start 2P', cursive;
        }

        .stat-value {
            font-size: 1rem;
            color: #00d4ff;
            text-shadow: 2px 2px #000;
        }

        .stat-label {
            font-size: 0.4rem;
            color: #666;
            margin-top: 4px;
        }

        /* Sidebar */
        .sidebar {
            background: #0a0a0a;
            border-left: 3px solid #7c3aed;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 15px;
            background: #111;
            border-bottom: 2px solid #333;
        }

        .sidebar-header h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: #7c3aed;
        }

        .company-name {
            font-size: 0.8rem;
            color: #888;
            margin-top: 8px;
        }

        /* Chat log */
        .chat-log {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .chat-entry {
            margin-bottom: 10px;
            padding: 8px;
            background: #111;
            border-left: 4px solid #333;
            animation: slideIn 0.2s ease;
            font-size: 0.75rem;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .chat-entry.openai { border-left-color: #10a37f; }
        .chat-entry.google { border-left-color: #4285f4; }
        .chat-entry.xai { border-left-color: #e44d26; }
        .chat-entry.dashscope { border-left-color: #ff6a00; }
        .chat-entry.system { border-left-color: #7c3aed; }
        .chat-entry.error { border-left-color: #ff4444; background: rgba(255,68,68,0.1); }

        .chat-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .chat-agent {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.45rem;
        }
        .chat-agent.openai { color: #10a37f; }
        .chat-agent.google { color: #4285f4; }
        .chat-agent.xai { color: #e44d26; }
        .chat-agent.dashscope { color: #ff6a00; }
        .chat-agent.system { color: #7c3aed; }

        .chat-time { font-size: 0.6rem; color: #444; }
        .chat-content { color: #999; line-height: 1.4; }

        /* Progress */
        .progress-section {
            padding: 12px 15px;
            background: #111;
            border-top: 2px solid #333;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.4rem;
            color: #666;
            margin-bottom: 6px;
        }

        .progress-bar {
            height: 12px;
            background: #222;
            border: 2px solid #444;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7c3aed);
            transition: width 0.3s;
            width: 0%;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden { display: none; }

        .loading-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: #00d4ff;
            animation: blink 1s infinite;
        }

        /* Agent Detail Modal */
        .agent-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .agent-modal.visible {
            display: flex;
            animation: modalFadeIn 0.2s ease-out;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(180deg, #1a1a3a 0%, #0d0d1a 100%);
            border: 3px solid #7c3aed;
            border-radius: 12px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(124, 58, 237, 0.5), 0 0 60px rgba(0, 212, 255, 0.2);
            animation: modalSlideIn 0.2s ease-out;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.9) translateY(20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid #333;
        }

        .modal-minion {
            width: 64px;
            height: 64px;
            flex-shrink: 0;
        }

        .modal-title-area {
            flex: 1;
        }

        .modal-agent-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .modal-agent-role {
            font-size: 0.75rem;
            color: #888;
        }

        .modal-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            text-transform: uppercase;
        }

        .modal-status.idle { background: #333; color: #666; }
        .modal-status.thinking { background: #00d4ff; color: #000; animation: blink 0.5s infinite; }
        .modal-status.complete { background: #00ff88; color: #000; }
        .modal-status.error { background: #ff4444; color: #fff; }

        .modal-close {
            background: none;
            border: 2px solid #666;
            color: #666;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .modal-close:hover {
            border-color: #ff4444;
            color: #ff4444;
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 20px;
            max-height: calc(80vh - 100px);
            overflow-y: auto;
        }

        .modal-section {
            margin-bottom: 20px;
        }

        .modal-section-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: #7c3aed;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .modal-info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .modal-info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 12px;
            border-radius: 8px;
            border-left: 3px solid #7c3aed;
        }

        .modal-info-label {
            font-size: 0.6rem;
            color: #666;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .modal-info-value {
            font-size: 0.85rem;
            color: #fff;
        }

        .modal-info-value.provider-openai { color: #10a37f; }
        .modal-info-value.provider-google { color: #4285f4; }
        .modal-info-value.provider-xai { color: #e44d26; }
        .modal-info-value.provider-dashscope { color: #ff6a00; }

        .modal-output {
            background: #0a0a12;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            color: #bbb;
            line-height: 1.7;
            max-height: 500px;
            min-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Special styling for live output */
        .modal-output.live {
            border-color: #7c3aed;
            box-shadow: 0 0 10px rgba(124, 58, 237, 0.3);
        }

        .modal-output::-webkit-scrollbar {
            width: 8px;
        }

        .modal-output::-webkit-scrollbar-track {
            background: #111;
        }

        .modal-output::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .modal-output::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .modal-empty {
            color: #444;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .modal-tier-badge {
            display: inline-block;
            background: #7c3aed;
            color: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.6rem;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-text">CONNECTING...</div>
    </div>

    <!-- Agent Detail Modal -->
    <div class="agent-modal" id="agent-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-minion" id="modal-minion"></div>
                <div class="modal-title-area">
                    <div class="modal-agent-name" id="modal-agent-name">Agent Name</div>
                    <div class="modal-agent-role" id="modal-agent-role">Role description</div>
                </div>
                <div class="modal-status idle" id="modal-status">Idle</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-section">
                    <div class="modal-section-title">Agent Info</div>
                    <div class="modal-info-grid">
                        <div class="modal-info-item">
                            <div class="modal-info-label">Provider</div>
                            <div class="modal-info-value" id="modal-provider">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Tier</div>
                            <div class="modal-info-value" id="modal-tier">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Started</div>
                            <div class="modal-info-value" id="modal-started">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Status</div>
                            <div class="modal-info-value" id="modal-status-text">Waiting</div>
                        </div>
                    </div>
                </div>
                <div class="modal-section">
                    <div class="modal-section-title">Current Task</div>
                    <div class="modal-output" id="modal-task">
                        <span class="modal-empty">No task assigned yet...</span>
                    </div>
                </div>
                <div class="modal-section">
                    <div class="modal-section-title">Output Preview</div>
                    <div class="modal-output" id="modal-output">
                        <span class="modal-empty">Waiting for agent to produce output...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="stage">
            <div class="pixel-grid"></div>

            <div class="header">
                <div class="title">EQUITY QUEST</div>
                <div class="ticker-display" id="ticker-display">---</div>
                <div class="status-bar">
                    <div class="status-dot connecting" id="status-dot"></div>
                    <span id="status-text" style="color:#888">WAIT</span>
                    <span id="timer" style="color:#00d4ff">00:00</span>
                </div>
            </div>

            <div class="flowchart" id="flowchart">
                <div class="flowchart-inner" id="flowchart-inner">
                    <svg class="connections-svg" id="connections-svg"></svg>
                    <!-- Agent nodes will be placed here -->
                </div>
            </div>

            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="nodes-done">0</div>
                    <div class="stat-label">COMPLETE</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="iterations">0</div>
                    <div class="stat-label">ROUNDS</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-chars">0</div>
                    <div class="stat-label">OUTPUT</div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="sidebar-header">
                <h2>RESEARCH LOG</h2>
                <div class="company-name" id="company-name">Waiting...</div>
            </div>
            <div class="chat-log" id="chat-log"></div>
            <div class="progress-section">
                <div class="progress-header">
                    <span>PROGRESS</span>
                    <span id="progress-pct">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Agent definitions with positions for flowchart layout
        // V4 Architecture: Continuous Quality Control with Bird's Eye Oversight
        // Key: Data Verifier + Data Checkpoint BEFORE debates, DCF AFTER debates
        const MINION_YELLOW = '#FFDA00';  // Classic banana yellow!

        // Agent role descriptions for the modal
        const agentDescriptions = {
            "START": "Entry point that initiates the research workflow and routes to the Research Supervisor.",
            "Research Supervisor": "Senior supervisor overseeing the entire equity research process. Creates research plans, reviews outputs, and ensures quality standards.",
            "Market Data Collector": "Specialized data gathering agent that collects comprehensive market data including price, financials, valuation multiples, and analyst data from multiple sources.",
            "Industry Deep Dive": "Industry analysis expert conducting exhaustive industry research including market size, competitive landscape, dynamics, and macro factors.",
            "Company Deep Dive": "Company analysis expert providing comprehensive company research including business model, competitive advantages (moat), management, and capital allocation.",
            "Data Verifier": "Independent data verification agent running parallel to collectors. Cross-references and validates key data points to ensure accuracy.",
            "Data Checkpoint": "Quality gate that blocks bad data before debates. Compares collector data vs verifier findings and decides if research can proceed.",
            "Debate Moderator": "Moderator overseeing the bull/bear debate. Frames key issues, sets debate rules, and ensures structured argumentation.",
            "Bull Advocate R1": "Bull case advocate presenting the strongest arguments for why the stock will outperform. Round 1 initial arguments.",
            "Bear Advocate R1": "Bear case advocate presenting the strongest arguments for why the stock will underperform. Round 1 initial arguments.",
            "Devils Advocate": "Challenges BOTH bull and bear arguments. Identifies weaknesses, fact-checks claims, and presents black swan scenarios.",
            "Bull Advocate R2": "Bull case advocate Round 2 rebuttal. Responds to bear arguments and Devil's Advocate challenges, introduces new arguments.",
            "Bear Advocate R2": "Bear case advocate Round 2 rebuttal. Responds to bull arguments and Devil's Advocate challenges, introduces new arguments.",
            "Debate Critic": "Evaluates debate argument quality, scores both sides, and synthesizes valuation inputs for the DCF model.",
            "Pre-Model Validator": "Validates all inputs BEFORE the DCF model is built. Ensures growth rates, margins, and WACC assumptions are reasonable.",
            "Financial Modeler": "Primary valuation engine building comprehensive DCF models with 5 scenarios (Super Bear to Super Bull) and probability-weighted values.",
            "DCF Validator": "Compares DCF output with broker research and analyst consensus. Validates divergence and ensures calculations are correct.",
            "Assumption Challenger": "Stress-tests every major DCF assumption. Challenges revenue growth, margins, WACC, and terminal value inputs.",
            "Comparable Validator": "Cross-checks DCF against comparable peer company valuations using relative multiples (EV/Revenue, EV/EBITDA, P/E).",
            "Sensitivity Auditor": "Analyzes how sensitive the DCF is to key assumptions. Tests WACC, terminal growth, revenue growth, and margin variations.",
            "Data Verification Gate": "Final data accuracy check before synthesis. Verifies price consistency, market cap, and internal consistency.",
            "Logic Verification Gate": "Final logical consistency check. Ensures recommendation matches valuation and identifies contradictions.",
            "Birds Eye Reviewer": "Holistic quality control reviewer seeing the full picture. Can route research back to any tier if issues found.",
            "Quality Supervisor": "Manages quality gates and routes appropriately based on gate results and Bird's Eye review.",
            "Synthesizer": "Creates the final comprehensive equity research report with all sections including executive summary, thesis, valuation, and risks.",
            "Research Supervisor Final Sign-off": "Final approval from Research Supervisor. Reviews completed report and signs off for publication."
        };

        // Short action descriptions for chatbox (what agent is currently DOING)
        const agentActions = {
            "START": "Initializing workflow, parsing ticker symbol...",
            "Research Supervisor": "Creating research plan, assigning tasks to specialists...",
            "Market Data Collector": "Fetching stock price, P/E ratio, market cap, 52-week range...",
            "Industry Deep Dive": "Analyzing TAM/SAM/SOM, competitive landscape, growth drivers...",
            "Company Deep Dive": "Evaluating business model, moat, management quality...",
            "Data Verifier": "Cross-checking data from multiple sources for accuracy...",
            "Data Checkpoint": "Validating all collected data before proceeding...",
            "Debate Moderator": "Setting debate rules, framing key valuation questions...",
            "Bull Advocate R1": "Building bullish thesis: growth catalysts, upside potential...",
            "Bear Advocate R1": "Building bearish thesis: risks, headwinds, downside scenarios...",
            "Devils Advocate": "Challenging both sides, identifying logical weaknesses...",
            "Bull Advocate R2": "Rebutting bear arguments, strengthening bull case...",
            "Bear Advocate R2": "Rebutting bull arguments, strengthening bear case...",
            "Debate Critic": "Scoring arguments, extracting DCF inputs from debate...",
            "Pre-Model Validator": "Checking growth rates, margins, WACC assumptions...",
            "Financial Modeler": "Running 5-scenario DCF: revenue projections, FCF, terminal value...",
            "DCF Validator": "Comparing DCF to broker targets, validating calculations...",
            "Assumption Challenger": "Stress-testing: What if growth is 50% lower?",
            "Comparable Validator": "Checking EV/Revenue, EV/EBITDA vs peer multiples...",
            "Sensitivity Auditor": "Testing WACC ±2%, terminal growth ±1% impact...",
            "Data Verification Gate": "Final price check, market cap verification...",
            "Logic Verification Gate": "Ensuring recommendation matches valuation logic...",
            "Birds Eye Reviewer": "Reviewing full analysis for inconsistencies...",
            "Quality Supervisor": "Routing based on gate results, ensuring quality...",
            "Synthesizer": "Writing executive summary, compiling final report...",
            "Research Supervisor Final Sign-off": "Final review, approving for publication..."
        };

        // Simulated debate phrases that rotate while agents are thinking
        const bullPhrases = [
            "Revenue growth could exceed 15% driven by market expansion...",
            "The TAM is significantly underestimated by consensus...",
            "Management has a proven track record of execution...",
            "Operating leverage will drive margin expansion...",
            "New product pipeline is underappreciated by the market...",
            "Market share gains in key segments justify premium...",
            "Strong balance sheet enables strategic M&A...",
            "Secular tailwinds support above-consensus growth...",
            "Valuation is compelling at current levels...",
            "Multiple expansion likely as profitability improves..."
        ];

        const bearPhrases = [
            "Revenue growth assumptions are overly optimistic...",
            "Competition is intensifying, threatening margins...",
            "Regulatory headwinds could materially impact earnings...",
            "Current valuation already prices in best-case scenario...",
            "Working capital deterioration signals demand weakness...",
            "Customer concentration risk is underappreciated...",
            "Execution risk is high given management turnover...",
            "Macro sensitivity could derail growth trajectory...",
            "Cash burn rate raises sustainability concerns...",
            "Historical performance doesn't support forward estimates..."
        ];

        const devilPhrases = [
            "Bull's growth assumption lacks supporting data...",
            "Bear ignores company's pricing power moat...",
            "Both sides fail to address currency exposure...",
            "What happens if key customer churns?",
            "Neither addresses geopolitical supply chain risk...",
            "Margin assumptions contradict industry trends...",
            "Terminal value dominates DCF - problematic...",
            "Bull's comparable set is cherry-picked...",
            "Bear's scenario ignores management optionality...",
            "Neither quantifies regulatory probability..."
        ];

        // Track current phrase indices for rotation
        let phraseIndices = { bull: 0, bear: 0, devil: 0 };

        function getSimulatedPhrase(nodeId) {
            if (nodeId.includes('Bull')) {
                const phrase = bullPhrases[phraseIndices.bull % bullPhrases.length];
                phraseIndices.bull++;
                return phrase;
            } else if (nodeId.includes('Bear')) {
                const phrase = bearPhrases[phraseIndices.bear % bearPhrases.length];
                phraseIndices.bear++;
                return phrase;
            } else if (nodeId.includes('Devil')) {
                const phrase = devilPhrases[phraseIndices.devil % devilPhrases.length];
                phraseIndices.devil++;
                return phrase;
            }
            return null;
        }

        // Rotate debate phrases every 3 seconds
        setInterval(() => {
            Object.keys(agentStartTimes).forEach(nodeId => {
                if (nodeId.includes('Bull') || nodeId.includes('Bear') || nodeId.includes('Devil')) {
                    const node = document.getElementById(`agent-${nodeId.replace(/\s/g, '-')}`);
                    if (node) {
                        const outputEl = node.querySelector('.chatbox-output');
                        // Only update if no actual output is displayed
                        if (outputEl && outputEl.textContent.includes('...') && !agentData[nodeId]?.output) {
                            const phrase = getSimulatedPhrase(nodeId);
                            if (phrase) {
                                outputEl.textContent = phrase;
                            }
                        }
                    }
                }
            });
        }, 3000);

        // Store detailed agent data for modal display
        let agentData = {};
        // Cache for node outputs from workflow result
        let nodeOutputsCache = {};
        let outputsCacheTime = 0;

        // Fetch node outputs from workflow result file
        async function fetchNodeOutputs() {
            // Cache for 5 seconds to avoid too many requests
            if (Date.now() - outputsCacheTime < 5000 && Object.keys(nodeOutputsCache).length > 0) {
                return nodeOutputsCache;
            }

            try {
                const resp = await fetch('/api/outputs');
                if (resp.ok) {
                    nodeOutputsCache = await resp.json();
                    outputsCacheTime = Date.now();
                }
            } catch (err) {
                console.error('Failed to fetch outputs:', err);
            }
            return nodeOutputsCache;
        }

        // Modal functions
        async function showAgentModal(agentId) {
            const agent = agents[agentId];
            if (!agent) return;

            const modal = document.getElementById('agent-modal');
            const data = agentData[agentId] || {};

            // Set minion avatar
            document.getElementById('modal-minion').innerHTML = agent.svg;

            // Set agent name and role
            document.getElementById('modal-agent-name').textContent = agentId;
            document.getElementById('modal-agent-role').textContent = agentDescriptions[agentId] || 'Research agent';

            // Set status
            const statusEl = document.getElementById('modal-status');
            const status = data.status || 'idle';
            statusEl.className = `modal-status ${status}`;
            statusEl.textContent = status === 'thinking' ? 'Working' : status === 'complete' ? 'Done' : status === 'error' ? 'Error' : 'Idle';

            // Set provider with color
            const providerEl = document.getElementById('modal-provider');
            const providerNames = { openai: 'OpenAI GPT-4o', google: 'Google Gemini', xai: 'xAI Grok', dashscope: 'Alibaba Qwen', system: 'System' };
            providerEl.textContent = providerNames[agent.provider] || agent.provider;
            providerEl.className = `modal-info-value provider-${agent.provider}`;

            // Set tier
            const tierNames = { 0: 'Orchestration', 1: 'Research', 1.5: 'Data Gate', 2: 'Debate', 2.5: 'Pre-Validation', 3: 'Valuation', 4: 'Quality Control', 5: 'Quality Gates', 6: 'Synthesis', 7: 'Final Sign-off' };
            document.getElementById('modal-tier').textContent = `Tier ${agent.tier} - ${tierNames[agent.tier] || 'Unknown'}`;

            // Set started time
            document.getElementById('modal-started').textContent = data.start_time ? new Date(data.start_time).toLocaleTimeString() : '-';

            // Set status text
            document.getElementById('modal-status-text').textContent = data.message || (status === 'idle' ? 'Waiting for task' : status);

            // Set task - show role description as the task
            const taskEl = document.getElementById('modal-task');
            taskEl.textContent = agentDescriptions[agentId] || 'Research task assigned by supervisor';

            // Show modal first (for better UX)
            modal.classList.add('visible');

            // Set output - first show loading, then fetch
            const outputEl = document.getElementById('modal-output');

            // Helper to format output nicely
            function formatOutput(content, maxLen = 8000) {
                if (!content) return '';
                let formatted = content;

                // Truncate if needed
                if (formatted.length > maxLen) {
                    formatted = formatted.slice(0, maxLen) + '\n\n━━━ [Output truncated - ' + content.length + ' total chars] ━━━';
                }

                return formatted;
            }

            // Check if we have output in agentData
            if (data.output) {
                outputEl.textContent = formatOutput(data.output);
            } else if (status === 'thinking') {
                // Agent is working - show live preview with simulated content
                let liveContent = '━━━ AGENT IS CURRENTLY WORKING ━━━\n\n';

                // Get current chatbox output if available
                const node = document.getElementById(`agent-${agentId.replace(/\s/g, '-')}`);
                if (node) {
                    const chatboxOutput = node.querySelector('.chatbox-output');
                    if (chatboxOutput && chatboxOutput.textContent) {
                        liveContent += '📝 Current Activity:\n' + chatboxOutput.textContent + '\n\n';
                    }
                }

                // Show action description
                liveContent += '🎯 Task: ' + (agentActions[agentId] || 'Processing...') + '\n\n';

                // For debate agents, show context
                if (agentId.includes('Bull')) {
                    liveContent += '🐂 Building bullish investment thesis...\n\n';
                    liveContent += 'Key areas being analyzed:\n';
                    liveContent += '• Revenue growth potential\n';
                    liveContent += '• Market expansion opportunities\n';
                    liveContent += '• Competitive advantages\n';
                    liveContent += '• Margin improvement catalysts\n';
                } else if (agentId.includes('Bear')) {
                    liveContent += '🐻 Building bearish investment thesis...\n\n';
                    liveContent += 'Key areas being analyzed:\n';
                    liveContent += '• Revenue growth risks\n';
                    liveContent += '• Competitive threats\n';
                    liveContent += '• Margin pressure factors\n';
                    liveContent += '• Valuation concerns\n';
                } else if (agentId.includes('Devil')) {
                    liveContent += '😈 Challenging both bull and bear arguments...\n\n';
                    liveContent += 'Examining:\n';
                    liveContent += '• Logical consistency\n';
                    liveContent += '• Evidence quality\n';
                    liveContent += '• Hidden assumptions\n';
                    liveContent += '• Black swan scenarios\n';
                }

                outputEl.textContent = liveContent;

                // Refresh the modal content periodically while working
                if (!window.modalRefreshInterval) {
                    window.modalRefreshInterval = setInterval(() => {
                        const currentData = agentData[agentId];
                        if (currentData?.status === 'complete' && currentData?.output) {
                            outputEl.textContent = formatOutput(currentData.output);
                            clearInterval(window.modalRefreshInterval);
                            window.modalRefreshInterval = null;
                        } else if (currentData?.status === 'thinking') {
                            // Update with latest chatbox content
                            const node = document.getElementById(`agent-${agentId.replace(/\s/g, '-')}`);
                            if (node) {
                                const chatboxOutput = node.querySelector('.chatbox-output');
                                if (chatboxOutput && chatboxOutput.textContent && chatboxOutput.textContent !== 'Generating response...') {
                                    const preview = '━━━ LIVE PREVIEW ━━━\n\n' + chatboxOutput.textContent + '\n\n━━━ Agent still working... ━━━';
                                    outputEl.textContent = preview;
                                }
                            }
                        }
                    }, 2000);
                }
            } else {
                // Try to fetch from workflow result
                outputEl.innerHTML = '<span class="modal-empty">Loading output...</span>';

                const outputs = await fetchNodeOutputs();
                const nodeOutput = outputs[agentId];

                if (nodeOutput && nodeOutput.content) {
                    outputEl.textContent = formatOutput(nodeOutput.content);

                    // Also update provider info if available
                    if (nodeOutput.provider) {
                        const providerNames = { openai: 'OpenAI GPT-4o', google: 'Google Gemini', xai: 'xAI Grok', dashscope: 'Alibaba Qwen', system: 'System' };
                        document.getElementById('modal-provider').textContent = providerNames[nodeOutput.provider] || nodeOutput.provider;
                        document.getElementById('modal-provider').className = `modal-info-value provider-${nodeOutput.provider}`;
                    }
                } else if (status === 'idle') {
                    outputEl.innerHTML = '<span class="modal-empty">⏳ Waiting for agent to be activated...</span>';
                } else {
                    outputEl.innerHTML = '<span class="modal-empty">📭 No output available yet</span>';
                }
            }
        }

        function closeModal() {
            document.getElementById('agent-modal').classList.remove('visible');
            // Clear any refresh intervals
            if (window.modalRefreshInterval) {
                clearInterval(window.modalRefreshInterval);
                window.modalRefreshInterval = null;
            }
        }

        // Close modal when clicking outside
        document.getElementById('agent-modal').addEventListener('click', function(e) {
            if (e.target === this) closeModal();
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeModal();
        });

        const agents = {
            // === TIER 0: ORCHESTRATION ===
            "START": {
                svg: createMinion(MINION_YELLOW, '🚀', 'goggles'),
                provider: "system", name: "START",
                x: 50, y: 2, tier: 0
            },
            "Research Supervisor": {
                svg: createMinion(MINION_YELLOW, '👔', 'smart'),
                provider: "openai", name: "SUPER",
                x: 50, y: 6, tier: 0
            },

            // === TIER 1: RESEARCH WORKERS + DATA VERIFIER (Parallel) ===
            "Market Data Collector": {
                svg: createMinion(MINION_YELLOW, '📊', 'one-eye'),
                provider: "google", name: "DATA",
                x: 20, y: 11, tier: 1
            },
            "Industry Deep Dive": {
                svg: createMinion(MINION_YELLOW, '🔬', 'two-eye'),
                provider: "openai", name: "INDUS",
                x: 40, y: 11, tier: 1
            },
            "Company Deep Dive": {
                svg: createMinion(MINION_YELLOW, '🏢', 'goggles'),
                provider: "openai", name: "COMP",
                x: 60, y: 11, tier: 1
            },
            "Data Verifier": {
                svg: createMinion(MINION_YELLOW, '✓', 'smart'),
                provider: "openai", name: "VERIFY",
                x: 80, y: 11, tier: 1
            },

            // === TIER 1.5: DATA CHECKPOINT (Gate Before Debates) ===
            "Data Checkpoint": {
                svg: createMinion(MINION_YELLOW, '🚦', 'goggles'),
                provider: "openai", name: "DCP",
                x: 50, y: 16, tier: 1.5
            },

            // === TIER 2: DEBATE SYSTEM ===
            "Debate Moderator": {
                svg: createMinion(MINION_YELLOW, '🎙️', 'goggles'),
                provider: "openai", name: "MOD",
                x: 50, y: 21, tier: 2
            },
            "Bull Advocate R1": {
                svg: createMinion(MINION_YELLOW, '🐂', 'happy'),
                provider: "xai", name: "BULL1",
                x: 35, y: 25, tier: 2
            },
            "Bear Advocate R1": {
                svg: createMinion(MINION_YELLOW, '🐻', 'angry'),
                provider: "dashscope", name: "BEAR1",
                x: 65, y: 25, tier: 2
            },
            "Devils Advocate": {
                svg: createMinion(MINION_YELLOW, '😈', 'smart'),
                provider: "openai", name: "DEVIL",
                x: 50, y: 29, tier: 2
            },
            "Bull Advocate R2": {
                svg: createMinion(MINION_YELLOW, '🐂', 'happy'),
                provider: "xai", name: "BULL2",
                x: 35, y: 33, tier: 2
            },
            "Bear Advocate R2": {
                svg: createMinion(MINION_YELLOW, '🐻', 'angry'),
                provider: "dashscope", name: "BEAR2",
                x: 65, y: 33, tier: 2
            },
            "Debate Critic": {
                svg: createMinion(MINION_YELLOW, '⚖️', 'smart'),
                provider: "openai", name: "CRIT",
                x: 50, y: 37, tier: 2
            },

            // === TIER 2.5: PRE-MODEL VALIDATOR (New in V4) ===
            "Pre-Model Validator": {
                svg: createMinion(MINION_YELLOW, '📋', 'two-eye'),
                provider: "openai", name: "PREVAL",
                x: 50, y: 41, tier: 2.5
            },

            // === TIER 3: FINANCIAL MODELING (POST-DEBATE) ===
            "Financial Modeler": {
                svg: createMinion(MINION_YELLOW, '💰', 'smart'),
                provider: "google", name: "DCF",
                x: 50, y: 45, tier: 3
            },

            // === TIER 4: VALUATION QUALITY CONTROL ===
            "DCF Validator": {
                svg: createMinion(MINION_YELLOW, '🔢', 'smart'),
                provider: "openai", name: "DCFV",
                x: 20, y: 50, tier: 4
            },
            "Assumption Challenger": {
                svg: createMinion(MINION_YELLOW, '❓', 'two-eye'),
                provider: "openai", name: "ASMQC",
                x: 40, y: 50, tier: 4
            },
            "Comparable Validator": {
                svg: createMinion(MINION_YELLOW, '📈', 'one-eye'),
                provider: "openai", name: "CMPQC",
                x: 60, y: 50, tier: 4
            },
            "Sensitivity Auditor": {
                svg: createMinion(MINION_YELLOW, '📉', 'two-eye'),
                provider: "openai", name: "SENQC",
                x: 80, y: 50, tier: 4
            },

            // === TIER 5: QUALITY GATES + BIRD'S EYE ===
            "Data Verification Gate": {
                svg: createMinion(MINION_YELLOW, '🔍', 'one-eye'),
                provider: "openai", name: "DCHK",
                x: 30, y: 55, tier: 5
            },
            "Logic Verification Gate": {
                svg: createMinion(MINION_YELLOW, '🧠', 'two-eye'),
                provider: "openai", name: "LCHK",
                x: 50, y: 55, tier: 5
            },
            "Birds Eye Reviewer": {
                svg: createMinion(MINION_YELLOW, '🦅', 'goggles'),
                provider: "openai", name: "BIRD",
                x: 70, y: 55, tier: 5
            },
            "Quality Supervisor": {
                svg: createMinion(MINION_YELLOW, '✅', 'goggles'),
                provider: "openai", name: "QASUP",
                x: 50, y: 60, tier: 5
            },

            // === TIER 6: SYNTHESIS ===
            "Synthesizer": {
                svg: createMinion(MINION_YELLOW, '📝', 'goggles'),
                provider: "openai", name: "SYNTH",
                x: 50, y: 65, tier: 6
            },

            // === TIER 7: FINAL SIGN-OFF ===
            "Research Supervisor Final Sign-off": {
                svg: createMinion(MINION_YELLOW, '✍️', 'smart'),
                provider: "openai", name: "FINAL",
                x: 50, y: 70, tier: 7
            }
        };

        // Create cute animated minion SVG with office personality
        function createMinion(color, tool, eyeType) {
            // Unique animation IDs for each minion to avoid conflicts
            const uid = Math.random().toString(36).substr(2, 9);

            const eyeStyles = {
                'one-eye': `<g class="eye-group">
                    <ellipse cx="32" cy="24" rx="14" ry="14" fill="#888" stroke="#555" stroke-width="3"/>
                    <circle cx="32" cy="24" r="8" fill="white"/>
                    <circle class="pupil" cx="32" cy="24" r="4" fill="#333">
                        <animate attributeName="cx" values="32;31;33;32" dur="4s" repeatCount="indefinite"/>
                    </circle>
                    <ellipse cx="33" cy="22" rx="2" ry="2" fill="white"/>
                    <!-- Blink animation -->
                    <ellipse cx="32" cy="24" rx="8" ry="8" fill="${color}">
                        <animate attributeName="ry" values="0;0;0;8;8;8;8;8;8;8;0" dur="5s" repeatCount="indefinite"/>
                    </ellipse>
                </g>`,
                'two-eye': `<g class="eye-group">
                    <ellipse cx="24" cy="24" rx="10" ry="10" fill="#888" stroke="#555" stroke-width="2"/>
                    <ellipse cx="40" cy="24" rx="10" ry="10" fill="#888" stroke="#555" stroke-width="2"/>
                    <circle cx="24" cy="24" r="6" fill="white"/><circle class="pupil-l" cx="24" cy="24" r="3" fill="#333">
                        <animate attributeName="cx" values="24;23;25;24" dur="3s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="40" cy="24" r="6" fill="white"/><circle class="pupil-r" cx="40" cy="24" r="3" fill="#333">
                        <animate attributeName="cx" values="40;39;41;40" dur="3s" repeatCount="indefinite"/>
                    </circle>
                    <!-- Blink left -->
                    <ellipse cx="24" cy="24" rx="6" ry="6" fill="${color}">
                        <animate attributeName="ry" values="0;0;0;0;6;6;0;0;0;0" dur="4s" repeatCount="indefinite"/>
                    </ellipse>
                    <!-- Blink right -->
                    <ellipse cx="40" cy="24" rx="6" ry="6" fill="${color}">
                        <animate attributeName="ry" values="0;0;0;0;6;6;0;0;0;0" dur="4s" repeatCount="indefinite"/>
                    </ellipse>
                </g>`,
                'goggles': `<g class="eye-group">
                    <rect x="12" y="18" width="40" height="14" rx="7" fill="#888" stroke="#555" stroke-width="2"/>
                    <circle cx="24" cy="25" r="6" fill="white"/>
                    <circle class="pupil-l" cx="24" cy="25" r="3" fill="#333">
                        <animate attributeName="cx" values="24;23;25;24" dur="3.5s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="40" cy="25" r="6" fill="white"/>
                    <circle class="pupil-r" cx="40" cy="25" r="3" fill="#333">
                        <animate attributeName="cx" values="40;39;41;40" dur="3.5s" repeatCount="indefinite"/>
                    </circle>
                    <rect x="8" y="22" width="6" height="6" fill="#555"/>
                    <rect x="50" y="22" width="6" height="6" fill="#555"/>
                    <!-- Goggle shine -->
                    <ellipse cx="20" cy="22" rx="2" ry="1" fill="rgba(255,255,255,0.3)">
                        <animate attributeName="opacity" values="0.3;0.6;0.3" dur="2s" repeatCount="indefinite"/>
                    </ellipse>
                </g>`,
                'happy': `<g class="eye-group">
                    <ellipse cx="24" cy="24" rx="8" ry="8" fill="#888" stroke="#555" stroke-width="2"/>
                    <ellipse cx="40" cy="24" rx="8" ry="8" fill="#888" stroke="#555" stroke-width="2"/>
                    <circle cx="24" cy="24" r="5" fill="white"/><circle class="pupil-l" cx="24" cy="22" r="3" fill="#333">
                        <animate attributeName="cy" values="22;21;23;22" dur="2s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="40" cy="24" r="5" fill="white"/><circle class="pupil-r" cx="40" cy="22" r="3" fill="#333">
                        <animate attributeName="cy" values="22;21;23;22" dur="2s" repeatCount="indefinite"/>
                    </circle>
                    <!-- Happy smile with animation -->
                    <path d="M22 38 Q32 45 42 38" stroke="#333" stroke-width="2" fill="none">
                        <animate attributeName="d" values="M22 38 Q32 45 42 38;M22 38 Q32 47 42 38;M22 38 Q32 45 42 38" dur="3s" repeatCount="indefinite"/>
                    </path>
                </g>`,
                'angry': `<g class="eye-group">
                    <ellipse cx="24" cy="24" rx="8" ry="8" fill="#888" stroke="#555" stroke-width="2"/>
                    <ellipse cx="40" cy="24" rx="8" ry="8" fill="#888" stroke="#555" stroke-width="2"/>
                    <circle cx="24" cy="24" r="5" fill="white"/><circle class="pupil-l" cx="24" cy="26" r="3" fill="#333"/>
                    <circle cx="40" cy="24" r="5" fill="white"/><circle class="pupil-r" cx="40" cy="26" r="3" fill="#333"/>
                    <!-- Angry eyebrows that twitch -->
                    <line x1="18" y1="18" x2="28" y2="22" stroke="#333" stroke-width="2">
                        <animate attributeName="y1" values="18;17;18" dur="1s" repeatCount="indefinite"/>
                    </line>
                    <line x1="46" y1="18" x2="36" y2="22" stroke="#333" stroke-width="2">
                        <animate attributeName="y1" values="18;17;18" dur="1s" repeatCount="indefinite"/>
                    </line>
                    <path d="M26 40 Q32 36 38 40" stroke="#333" stroke-width="2" fill="none"/>
                </g>`,
                'smart': `<g class="eye-group">
                    <ellipse cx="24" cy="24" rx="9" ry="9" fill="#888" stroke="#555" stroke-width="2"/>
                    <ellipse cx="40" cy="24" rx="9" ry="9" fill="#888" stroke="#555" stroke-width="2"/>
                    <circle cx="24" cy="24" r="6" fill="white"/><circle class="pupil-l" cx="24" cy="24" r="3" fill="#333">
                        <animate attributeName="cx" values="24;22;26;24" dur="5s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="40" cy="24" r="6" fill="white"/><circle class="pupil-r" cx="40" cy="24" r="3" fill="#333">
                        <animate attributeName="cx" values="40;38;42;40" dur="5s" repeatCount="indefinite"/>
                    </circle>
                    <!-- Thinking eyebrows -->
                    <line x1="18" y1="16" x2="30" y2="18" stroke="#333" stroke-width="2">
                        <animate attributeName="y2" values="18;17;18" dur="2s" repeatCount="indefinite"/>
                    </line>
                    <line x1="46" y1="16" x2="34" y2="18" stroke="#333" stroke-width="2">
                        <animate attributeName="y2" values="18;17;18" dur="2s" repeatCount="indefinite"/>
                    </line>
                </g>`
            };

            return `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" class="minion-svg">
                <!-- Shadow under minion -->
                <ellipse cx="32" cy="58" rx="16" ry="3" fill="rgba(0,0,0,0.2)">
                    <animate attributeName="rx" values="16;14;16" dur="3s" repeatCount="indefinite"/>
                </ellipse>
                <!-- Body with breathing animation -->
                <g class="body-group">
                    <ellipse cx="32" cy="42" rx="22" ry="18" fill="${color}">
                        <animate attributeName="ry" values="18;18.5;18" dur="3s" repeatCount="indefinite"/>
                    </ellipse>
                </g>
                <!-- Overalls -->
                <rect x="14" y="38" width="36" height="20" rx="4" fill="#1e40af"/>
                <rect x="20" y="40" width="24" height="12" fill="#1e3a8a"/>
                <!-- Pocket -->
                <rect x="26" y="44" width="12" height="6" rx="1" fill="#1e3a8a" stroke="#0f2557" stroke-width="1"/>
                <!-- Straps -->
                <rect x="18" y="32" width="6" height="14" fill="#1e40af"/>
                <rect x="40" y="32" width="6" height="14" fill="#1e40af"/>
                <!-- Buttons -->
                <circle cx="21" cy="34" r="2" fill="#333"/>
                <circle cx="43" cy="34" r="2" fill="#333"/>
                <!-- Head -->
                <ellipse cx="32" cy="28" rx="20" ry="18" fill="${color}"/>
                <!-- Eyes -->
                ${eyeStyles[eyeType] || eyeStyles['two-eye']}
                <!-- Mouth with subtle animation -->
                <ellipse cx="32" cy="38" rx="6" ry="3" fill="#333">
                    <animate attributeName="ry" values="3;3.5;3" dur="4s" repeatCount="indefinite"/>
                </ellipse>
                <!-- Hair with wiggle -->
                <g class="hair">
                    <path d="M24 10 Q26 6 28 10" stroke="#333" stroke-width="2" fill="none">
                        <animate attributeName="d" values="M24 10 Q26 6 28 10;M24 11 Q26 5 28 11;M24 10 Q26 6 28 10" dur="2s" repeatCount="indefinite"/>
                    </path>
                    <path d="M32 8 Q34 4 36 8" stroke="#333" stroke-width="2" fill="none">
                        <animate attributeName="d" values="M32 8 Q34 4 36 8;M32 9 Q34 3 36 9;M32 8 Q34 4 36 8" dur="2.5s" repeatCount="indefinite"/>
                    </path>
                    <path d="M38 10 Q40 6 42 10" stroke="#333" stroke-width="2" fill="none">
                        <animate attributeName="d" values="M38 10 Q40 6 42 10;M38 11 Q40 5 42 11;M38 10 Q40 6 42 10" dur="2.2s" repeatCount="indefinite"/>
                    </path>
                </g>
                <!-- Tool badge with glow -->
                <g class="badge">
                    <circle cx="50" cy="50" r="10" fill="white" stroke="#333" stroke-width="1">
                        <animate attributeName="r" values="10;10.5;10" dur="2s" repeatCount="indefinite"/>
                    </circle>
                    <text x="50" y="54" text-anchor="middle" font-size="12">${tool}</text>
                </g>
                <!-- Arms (simple) -->
                <ellipse cx="10" cy="42" rx="4" ry="6" fill="${color}">
                    <animate attributeName="cy" values="42;41;42" dur="3s" repeatCount="indefinite"/>
                </ellipse>
                <ellipse cx="54" cy="42" rx="4" ry="6" fill="${color}">
                    <animate attributeName="cy" values="42;43;42" dur="3s" repeatCount="indefinite"/>
                </ellipse>
            </svg>`;
        }

        // Connections between agents (from -> to) - V4 Enhanced Workflow
        // Key: Data Verifier + Data Checkpoint BEFORE debates, DCF AFTER all debates
        const connections = [
            // Tier 0: Orchestration
            ["START", "Research Supervisor"],

            // Tier 1: Parallel Research + Data Verifier
            ["Research Supervisor", "Market Data Collector"],
            ["Research Supervisor", "Industry Deep Dive"],
            ["Research Supervisor", "Company Deep Dive"],
            ["Research Supervisor", "Data Verifier"],

            // Tier 1.5: All collectors + verifier -> Data Checkpoint
            ["Market Data Collector", "Data Checkpoint"],
            ["Industry Deep Dive", "Data Checkpoint"],
            ["Company Deep Dive", "Data Checkpoint"],
            ["Data Verifier", "Data Checkpoint"],

            // Tier 2: Debate System (AFTER Data Checkpoint verifies data)
            ["Data Checkpoint", "Debate Moderator"],
            ["Debate Moderator", "Bull Advocate R1"],
            ["Debate Moderator", "Bear Advocate R1"],
            ["Bull Advocate R1", "Devils Advocate"],
            ["Bear Advocate R1", "Devils Advocate"],
            ["Devils Advocate", "Bull Advocate R2"],
            ["Devils Advocate", "Bear Advocate R2"],
            ["Bull Advocate R2", "Debate Critic"],
            ["Bear Advocate R2", "Debate Critic"],

            // Tier 2.5: Pre-Model Validator
            ["Debate Critic", "Pre-Model Validator"],
            ["Pre-Model Validator", "Financial Modeler"],

            // Tier 3: Financial Modeling triggers 4 parallel QC agents
            ["Financial Modeler", "DCF Validator"],
            ["Financial Modeler", "Assumption Challenger"],
            ["Financial Modeler", "Comparable Validator"],
            ["Financial Modeler", "Sensitivity Auditor"],

            // Tier 4: QC agents feed directly to Quality Gates (no Valuation Committee)
            ["DCF Validator", "Data Verification Gate"],
            ["Assumption Challenger", "Data Verification Gate"],
            ["Assumption Challenger", "Logic Verification Gate"],
            ["Assumption Challenger", "Birds Eye Reviewer"],

            // Tier 5: Quality Gates feed into Quality Supervisor
            ["Data Verification Gate", "Quality Supervisor"],
            ["Logic Verification Gate", "Quality Supervisor"],
            ["Birds Eye Reviewer", "Quality Supervisor"],

            // Tier 6: Quality Supervisor routes to Synthesizer
            ["Quality Supervisor", "Synthesizer"],

            // Tier 7: Synthesizer to Final Sign-off
            ["Synthesizer", "Research Supervisor Final Sign-off"]
        ];

        let ws = null;
        let startTime = null;
        let timerInterval = null;
        let nodesDone = 0;
        let totalChars = 0;
        let activeConnections = new Set();

        // Initialize the flowchart
        function initFlowchart() {
            const container = document.getElementById('flowchart-inner');
            const svg = document.getElementById('connections-svg');

            // Clear
            container.querySelectorAll('.agent-node').forEach(n => n.remove());
            svg.innerHTML = '';

            // Get container dimensions
            const rect = container.getBoundingClientRect();

            // Draw connections first
            connections.forEach(([from, to], idx) => {
                const fromAgent = agents[from];
                const toAgent = agents[to];
                if (!fromAgent || !toAgent) return;

                const x1 = (fromAgent.x / 100) * rect.width;
                const y1 = (fromAgent.y / 100) * rect.height + 24;
                const x2 = (toAgent.x / 100) * rect.width;
                const y2 = (toAgent.y / 100) * rect.height - 6;

                // Create curved path
                const midY = (y1 + y2) / 2;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M${x1},${y1} C${x1},${midY} ${x2},${midY} ${x2},${y2}`);
                path.setAttribute('class', 'connection');
                path.setAttribute('id', `conn-${from.replace(/\s/g, '-')}-${to.replace(/\s/g, '-')}`);
                svg.appendChild(path);
            });

            // Create agent nodes
            Object.entries(agents).forEach(([id, agent]) => {
                const node = document.createElement('div');
                node.className = 'agent-node idle';
                node.id = `agent-${id.replace(/\s/g, '-')}`;
                node.style.left = `calc(${agent.x}% - 22px)`;
                node.style.top = `calc(${agent.y}% - 22px)`;

                // Determine which side to show chatbox (left side of screen = chatbox on right, vice versa)
                const side = agent.x > 50 ? 'left' : 'right';
                node.setAttribute('data-side', side);

                // Get task description for this agent
                const actionDesc = agentActions[id] || 'Processing data...';

                // Determine debate class
                let debateClass = '';
                if (id.includes('Bull')) debateClass = 'debate-bull';
                else if (id.includes('Bear')) debateClass = 'debate-bear';
                else if (id.includes('Devil')) debateClass = 'debate-devil';

                // Provider display names
                const providerNames = { openai: 'OpenAI', google: 'Gemini', xai: 'Grok', dashscope: 'Qwen', system: 'System' };

                node.innerHTML = `
                    <div class="speech-bubble">Ready</div>
                    <div class="minion-avatar ${agent.provider}">${agent.svg}</div>
                    <div class="agent-name">${agent.name}</div>
                    <div class="agent-chatbox provider-${agent.provider} ${debateClass}" data-agent-id="${id}">
                        <span class="expand-hint">🔍 Click to expand</span>
                        <div class="chatbox-header">
                            <div class="chatbox-status"></div>
                            <div class="chatbox-title">Working</div>
                            <div class="chatbox-ticker">---</div>
                        </div>
                        <div class="chatbox-agent-name">${id}</div>
                        <div class="chatbox-task">${actionDesc}</div>
                        <div class="chatbox-output typing"></div>
                        <div class="chatbox-progress">
                            <div class="chatbox-progress-bar">
                                <div class="chatbox-progress-fill"></div>
                            </div>
                            <div class="chatbox-time">00:00</div>
                        </div>
                        <div class="chatbox-provider">
                            <div class="chatbox-provider-dot ${agent.provider}"></div>
                            <span>Powered by ${providerNames[agent.provider] || agent.provider}</span>
                        </div>
                    </div>
                `;

                // Add click handler to minion to show agent details
                node.querySelector('.minion-avatar').addEventListener('click', (e) => {
                    e.stopPropagation();
                    showAgentModal(id);
                });

                // Add click handler to chatbox to show expanded view
                const chatbox = node.querySelector('.agent-chatbox');
                chatbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showAgentModal(id);
                });

                container.appendChild(node);
            });
        }

        // Track agent start times for elapsed time display
        let agentStartTimes = {};

        // Current ticker for chatbox display
        let currentTicker = '---';

        // Set agent state
        function setAgentState(nodeId, state, message = '', taskOverride = null, outputPreview = null) {
            const node = document.getElementById(`agent-${nodeId.replace(/\s/g, '-')}`);
            if (!node) return;

            // Keep data-side attribute when updating class
            const side = node.getAttribute('data-side');
            node.className = `agent-node ${state}`;
            if (side) node.setAttribute('data-side', side);

            const bubble = node.querySelector('.speech-bubble');
            if (message && bubble) {
                bubble.textContent = message.length > 15 ? message.slice(0, 12) + '...' : message;
            }

            // Update chatbox
            const chatbox = node.querySelector('.agent-chatbox');
            if (chatbox) {
                const titleEl = chatbox.querySelector('.chatbox-title');
                const taskEl = chatbox.querySelector('.chatbox-task');
                const timeEl = chatbox.querySelector('.chatbox-time');
                const tickerEl = chatbox.querySelector('.chatbox-ticker');
                const outputEl = chatbox.querySelector('.chatbox-output');

                // Update ticker
                if (tickerEl && currentTicker) {
                    tickerEl.textContent = currentTicker;
                }

                // Update title based on state
                if (state === 'thinking') {
                    // Custom titles for debate agents
                    if (nodeId.includes('Bull')) {
                        titleEl.textContent = '🐂 BULL CASE';
                    } else if (nodeId.includes('Bear')) {
                        titleEl.textContent = '🐻 BEAR CASE';
                    } else if (nodeId.includes('Devil')) {
                        titleEl.textContent = '😈 CHALLENGING';
                    } else {
                        titleEl.textContent = 'Analyzing...';
                    }
                    // Track start time
                    if (!agentStartTimes[nodeId]) {
                        agentStartTimes[nodeId] = Date.now();
                    }
                } else if (state === 'active') {
                    titleEl.textContent = 'Starting';
                    agentStartTimes[nodeId] = Date.now();
                } else if (state === 'complete') {
                    titleEl.textContent = '✓ Complete';
                    delete agentStartTimes[nodeId];
                } else if (state === 'error') {
                    titleEl.textContent = '✗ Error';
                    delete agentStartTimes[nodeId];
                }

                // Update task description
                if (taskOverride) {
                    taskEl.textContent = taskOverride;
                }

                // Update output preview - show actual agent output or simulated debate content
                if (outputEl) {
                    if (outputPreview && outputPreview.length > 0) {
                        // Real streaming output available - show it!
                        let cleanOutput = outputPreview
                            .replace(/```[\s\S]*?```/g, '[code]')  // Replace code blocks
                            .replace(/#+\s*/g, '')                  // Remove markdown headers
                            .replace(/\*\*/g, '')                   // Remove bold
                            .replace(/\n{2,}/g, '\n')               // Collapse multiple newlines
                            .trim();

                        // Show last ~300 chars for a "live typing" effect
                        if (cleanOutput.length > 300) {
                            cleanOutput = '...' + cleanOutput.slice(-297);
                        }

                        outputEl.textContent = cleanOutput;
                        outputEl.classList.add('typing');
                        outputEl.style.display = 'block';

                        // Add streaming indicator
                        if (state === 'thinking') {
                            outputEl.style.borderLeft = '3px solid #00ff88';
                        } else {
                            outputEl.style.borderLeft = 'none';
                        }
                    } else if (state === 'thinking') {
                        // No real output yet - show placeholder
                        // For debate agents, show simulated phrases
                        if (nodeId.includes('Bull') || nodeId.includes('Bear') || nodeId.includes('Devil')) {
                            const phrase = getSimulatedPhrase(nodeId);
                            outputEl.textContent = phrase || 'Formulating argument...';
                        } else {
                            // Show action-specific placeholder for other agents
                            const action = agentActions[nodeId] || 'Processing...';
                            outputEl.textContent = action;
                        }
                        outputEl.classList.add('typing');
                        outputEl.style.display = 'block';
                        outputEl.style.borderLeft = 'none';
                    } else if (state === 'complete') {
                        outputEl.classList.remove('typing');
                        outputEl.style.borderLeft = 'none';
                        if (!outputPreview) {
                            // Show completion message if no output
                            outputEl.textContent = '✓ Analysis complete';
                            outputEl.style.display = 'block';
                        }
                    } else {
                        outputEl.style.display = 'none';
                        outputEl.style.borderLeft = 'none';
                    }
                }

                // Update elapsed time
                if (agentStartTimes[nodeId]) {
                    const elapsed = Math.floor((Date.now() - agentStartTimes[nodeId]) / 1000);
                    const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const sec = (elapsed % 60).toString().padStart(2, '0');
                    timeEl.textContent = `${min}:${sec}`;
                }
            }
        }

        // Update chatbox times periodically
        setInterval(() => {
            Object.entries(agentStartTimes).forEach(([nodeId, startTime]) => {
                const node = document.getElementById(`agent-${nodeId.replace(/\s/g, '-')}`);
                if (node) {
                    const timeEl = node.querySelector('.chatbox-time');
                    if (timeEl) {
                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                        const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
                        const sec = (elapsed % 60).toString().padStart(2, '0');
                        timeEl.textContent = `${min}:${sec}`;
                    }
                }
            });
        }, 1000);

        // Activate connection
        function activateConnection(from, to) {
            const connId = `conn-${from.replace(/\s/g, '-')}-${to.replace(/\s/g, '-')}`;
            const conn = document.getElementById(connId);
            if (conn) {
                conn.classList.add('active');
                activeConnections.add(connId);
            }
        }

        // Complete connection
        function completeConnection(from, to) {
            const connId = `conn-${from.replace(/\s/g, '-')}-${to.replace(/\s/g, '-')}`;
            const conn = document.getElementById(connId);
            if (conn) {
                conn.classList.remove('active');
                conn.classList.add('complete');
            }
        }

        // Add chat entry
        function addChat(agent, message, provider = 'system') {
            const log = document.getElementById('chat-log');
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });

            const entry = document.createElement('div');
            entry.className = `chat-entry ${provider}`;
            entry.innerHTML = `
                <div class="chat-header">
                    <span class="chat-agent ${provider}">${agent}</span>
                    <span class="chat-time">${time}</span>
                </div>
                <div class="chat-content">${message}</div>
            `;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Update progress
        function updateProgress(pct) {
            document.getElementById('progress-fill').style.width = `${pct}%`;
            document.getElementById('progress-pct').textContent = `${Math.round(pct)}%`;
        }

        // Update timer
        function updateTimer() {
            if (!startTime) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const sec = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${min}:${sec}`;
        }

        // Track previous node for connections
        let previousNode = null;

        // Handle events
        function handleEvent(msg) {
            const { type, data } = msg;

            switch (type) {
                case 'connected':
                    addChat('SYSTEM', 'Connected!', 'system');
                    break;

                case 'workflow_init':
                    document.getElementById('ticker-display').textContent = data.ticker;
                    startTime = Date.now();
                    timerInterval = setInterval(updateTimer, 1000);
                    document.getElementById('status-dot').className = 'status-dot running';
                    document.getElementById('status-text').textContent = 'RUN';
                    addChat('SYSTEM', `Starting: ${data.ticker}`, 'system');
                    break;

                case 'company_info':
                    document.getElementById('company-name').textContent = data.company_name;
                    break;

                case 'node_start':
                    // Get task description for chatbox
                    const taskDesc = agentDescriptions[data.node_id] || 'Processing...';
                    setAgentState(data.node_id, 'thinking', 'Working...', taskDesc);
                    // Activate incoming connection
                    if (previousNode) {
                        activateConnection(previousNode, data.node_id);
                    }
                    const def = agents[data.node_id];
                    if (def) addChat(data.node_id, 'Analyzing...', def.provider);
                    break;

                case 'node_complete':
                    setAgentState(data.node_id, 'complete', 'Done!', 'Task completed successfully');
                    // Complete incoming connection
                    if (previousNode) {
                        completeConnection(previousNode, data.node_id);
                    }
                    previousNode = data.node_id;
                    nodesDone++;
                    document.getElementById('nodes-done').textContent = nodesDone;
                    if (data.details?.output_length) {
                        totalChars += data.details.output_length;
                        document.getElementById('total-chars').textContent =
                            totalChars > 1000 ? `${(totalChars/1000).toFixed(0)}K` : totalChars;
                    }
                    updateProgress(Math.min((nodesDone / 21) * 100, 100));  // 21 nodes in v3 workflow
                    break;

                case 'node_error':
                    setAgentState(data.node_id, 'error', 'ERROR!');
                    addChat(data.node_id, 'API Error!', 'error');
                    break;

                case 'node_triggered':
                    setAgentState(data.node_id, 'active', 'Ready!');
                    break;

                case 'iteration_start':
                    document.getElementById('iterations').textContent = data.details?.iteration || 0;
                    break;

                case 'workflow_complete':
                    clearInterval(timerInterval);
                    document.getElementById('status-dot').className = 'status-dot complete';
                    document.getElementById('status-text').textContent = 'WIN!';
                    updateProgress(100);
                    addChat('SYSTEM', `Done in ${data.execution_time?.toFixed(0)}s!`, 'system');
                    break;

                case 'node_output':
                    const prov = agents[data.node_id]?.provider || 'system';
                    const preview = data.content_preview?.slice(0, 60) + '...';
                    addChat(data.node_id, preview, prov);
                    break;
            }
        }

        // Poll HTTP API for state updates
        let pollInterval = null;
        let lastUpdate = null;
        let renderedChatCount = 0;

        async function fetchState() {
            try {
                const resp = await fetch('/api/state');
                if (!resp.ok) throw new Error('HTTP error');
                const state = await resp.json();

                // Update UI with state data
                if (state.last_updated !== lastUpdate) {
                    lastUpdate = state.last_updated;
                    renderState(state);
                }
            } catch (err) {
                console.error('Fetch error:', err);
                document.getElementById('status-dot').className = 'status-dot';
                document.getElementById('status-text').textContent = 'OFF';
            }
        }

        function renderState(state) {
            // Update ticker and company name
            if (state.ticker) {
                document.getElementById('ticker-display').textContent = state.ticker;
                currentTicker = state.ticker;  // Store for chatboxes
            }
            if (state.company_name) {
                document.getElementById('company-name').textContent = state.company_name;
            }

            // Update progress
            updateProgress(state.progress || 0);

            // Update stats
            document.getElementById('nodes-done').textContent = state.nodes_done || 0;
            document.getElementById('iterations').textContent = state.iterations || 0;

            // Format total chars
            const totalChars = state.total_chars || 0;
            document.getElementById('total-chars').textContent =
                totalChars > 1000 ? `${(totalChars/1000).toFixed(0)}K` : totalChars;

            // Update agent states from state.agents (now a dictionary)
            Object.entries(state.agents || {}).forEach(([nodeId, agent]) => {
                // Store agent data for modal display
                agentData[nodeId] = {
                    ...agentData[nodeId],  // Preserve existing data
                    ...agent,              // Update with new data
                    status: agent.status,
                    message: agent.message,
                    start_time: agent.start_time,
                    output: agent.output || agentData[nodeId]?.output,  // Keep output if not in update
                    task: agent.task || agentData[nodeId]?.task
                };

                let uiState = 'idle';
                if (agent.status === 'thinking') uiState = 'thinking';
                else if (agent.status === 'active') uiState = 'active';
                else if (agent.status === 'complete') uiState = 'complete';
                else if (agent.status === 'error') uiState = 'error';

                // Get action description for chatbox
                const actionText = agentActions[nodeId] || 'Processing data...';

                // Get output preview - show actual agent output if available
                let outputPreview = null;
                if (agent.output && agent.output.length > 0) {
                    outputPreview = agent.output;
                }

                setAgentState(nodeId, uiState, agent.message || 'Ready', actionText, outputPreview);
            });

            // Update connections
            (state.connections || []).forEach(conn => {
                if (conn.status === 'active') {
                    activateConnection(conn.from, conn.to);
                } else if (conn.status === 'complete') {
                    completeConnection(conn.from, conn.to);
                }
            });

            // Add new chat messages (only new ones)
            const chatLog = state.chat_log || [];
            if (chatLog.length > renderedChatCount) {
                for (let i = renderedChatCount; i < chatLog.length; i++) {
                    const entry = chatLog[i];
                    addChatDirect(entry.agent, entry.message, entry.provider, entry.time);
                }
                renderedChatCount = chatLog.length;
            }

            // Update status indicator based on workflow status
            if (state.status === 'running') {
                document.getElementById('status-dot').className = 'status-dot running';
                document.getElementById('status-text').textContent = 'RUN';
            } else if (state.status === 'complete') {
                document.getElementById('status-dot').className = 'status-dot complete';
                document.getElementById('status-text').textContent = 'WIN';
            } else if (state.status === 'error') {
                document.getElementById('status-dot').className = 'status-dot';
                document.getElementById('status-text').textContent = 'ERR';
            } else if (state.status === 'waiting' || state.status === 'idle') {
                document.getElementById('status-dot').className = 'status-dot connected';
                document.getElementById('status-text').textContent = 'WAIT';
            }
        }

        // Add chat entry with provided timestamp (for state sync)
        function addChatDirect(agent, message, provider = 'system', time = null) {
            const log = document.getElementById('chat-log');
            const timeStr = time || new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });

            const entry = document.createElement('div');
            entry.className = `chat-entry ${provider}`;
            entry.innerHTML = `
                <div class="chat-header">
                    <span class="chat-agent ${provider}">${agent}</span>
                    <span class="chat-time">${timeStr}</span>
                </div>
                <div class="chat-content">${message}</div>
            `;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function connect() {
            console.log('Starting HTTP polling from /api/state');
            document.getElementById('loading-overlay').classList.add('hidden');
            document.getElementById('status-dot').className = 'status-dot connecting';
            document.getElementById('status-text').textContent = 'POLL';
            addChat('SYSTEM', 'Visualizer ready - waiting for workflow...', 'system');

            // Start timer
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);

            // Poll immediately then every 500ms for real-time feel
            fetchState();
            pollInterval = setInterval(fetchState, 500);
        }

        // Init
        initFlowchart();
        connect();
        window.addEventListener('resize', initFlowchart);
    </script>
</body>
</html>
